"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LicenseManager = exports.ManagementMode = void 0;
var fs = __importStar(require("fs-extra"));
var os_1 = require("os");
var path = __importStar(require("path"));
var config_parser_1 = require("./config-parser");
var license_formatter_1 = require("./license-formatter");
var ManagementMode;
(function (ManagementMode) {
    ManagementMode[ManagementMode["CHECK"] = 1] = "CHECK";
    ManagementMode[ManagementMode["INSERT"] = 2] = "INSERT";
    ManagementMode[ManagementMode["REMOVE"] = 3] = "REMOVE";
})(ManagementMode = exports.ManagementMode || (exports.ManagementMode = {}));
var REGEX_MARKER = 'I_AM_A_REGEX_MARKER';
var LicenseManager = /** @class */ (function () {
    function LicenseManager(paths, licenseText, declaredFormats, defaultFormat, trailingWhitespace, mode, outputPath, regex) {
        this.paths = paths;
        this.licenseFormatter = declaredFormats ?
            new license_formatter_1.LicenseFormatter(defaultFormat, trailingWhitespace, declaredFormats) :
            new license_formatter_1.LicenseFormatter(defaultFormat, trailingWhitespace);
        this.licenseText = licenseText;
        this.mode = mode;
        this.outputPath = outputPath;
        this.trailingWhitespace = trailingWhitespace;
        this.regex = regex;
        this.formattedLicenses = new Map();
    }
    LicenseManager.prototype.manage = function () {
        var _this = this;
        var missingLicenses = [];
        var insertedLicenses = [];
        var removedLicenses = [];
        this.paths.forEach(function (filePath) {
            var fileContents = fs.readFileSync(filePath).toString();
            var normalisedFileContents = _this.formatForCheck(fileContents, false, _this.regex);
            var extension = path.extname(filePath) ? path.extname(filePath) : path.basename(filePath);
            var existing;
            if (_this.formattedLicenses.has(extension)) {
                existing = _this.formattedLicenses.get(extension);
            }
            var formattedLicense = existing ? existing.formatted
                : _this.licenseFormatter.formatLicenseForFile(extension, _this.licenseText);
            var normalisedLicense = existing ? existing.normalised
                : _this.formatForCheck(formattedLicense, true, _this.regex);
            if (!existing) {
                _this.formattedLicenses.set(extension, { formatted: formattedLicense, normalised: normalisedLicense });
            }
            if (!normalisedFileContents.match(new RegExp(normalisedLicense))) {
                if (_this.mode === ManagementMode.INSERT) {
                    _this.insertLicense(fileContents, formattedLicense, filePath, _this.regex);
                    insertedLicenses.push(filePath);
                }
                else if (_this.mode === ManagementMode.CHECK) {
                    console.error('\x1b[31m\u2717\x1b[0m License not found in', filePath);
                    missingLicenses.push(filePath);
                }
            }
            else if (_this.mode === ManagementMode.REMOVE) {
                _this.removeLicense(fileContents, normalisedLicense, filePath);
                removedLicenses.push(filePath);
            }
        });
        if (this.outputPath) {
            switch (this.mode) {
                case ManagementMode.INSERT:
                    fs.writeFileSync(this.outputPath, insertedLicenses.join(os_1.EOL));
                    break;
                case ManagementMode.CHECK:
                    fs.writeFileSync(this.outputPath, missingLicenses.join(os_1.EOL));
                    break;
                case ManagementMode.REMOVE:
                    fs.writeFileSync(this.outputPath, removedLicenses.join(os_1.EOL));
                    break;
            }
        }
        if (this.mode !== ManagementMode.REMOVE) {
            /* istanbul ignore else  */
            if (this.mode === ManagementMode.INSERT) {
                console.log("\u001B[33m!\u001B[0m Inserted license into " + insertedLicenses.length + " file(s)");
            }
            else if (this.mode === ManagementMode.CHECK) {
                if (missingLicenses.length > 0) {
                    throw new Error("License check failed. " + missingLicenses.length + " file(s) did not have the license.");
                }
                console.log('\x1b[32m\u2714\x1b[0m All files have licenses.');
            }
        }
        else {
            console.log("\u001B[32m\u2714\u001B[0m Removed license from " + removedLicenses.length + " file(s).");
        }
    };
    LicenseManager.prototype.insertLicense = function (fileContents, formattedLicense, filePath, regex) {
        var newText = '';
        if (regex) {
            var identifierChoice_1 = 0;
            formattedLicense = formattedLicense.split(/\r?\n/).map(function (line) {
                return line.split(regex.identifier).map(function (el, idx) {
                    if (idx % 2 === 0) {
                        return el;
                    }
                    else {
                        var replacement = regex.replacements[0];
                        if (regex.replacements.length > 1) {
                            if (identifierChoice_1 === regex.replacements.length) {
                                throw new Error("Too few replacement values passed. Found at least " + (identifierChoice_1 + 1) + " regex values. " +
                                    ("Only have " + regex.replacements.length + " replacements"));
                            }
                            replacement = regex.replacements[identifierChoice_1++];
                        }
                        if (!replacement.match(el)) {
                            throw new Error("Replacement value " + replacement + " does not match regex it is to replace: " + el);
                        }
                        return replacement;
                    }
                }).join('');
            }).join(os_1.EOL);
        }
        if (fileContents.startsWith('#!')) {
            var lines = fileContents.split(/\r?\n/);
            newText = lines[0] + os_1.EOL + formattedLicense;
            lines.shift();
            newText += os_1.EOL + lines.join(os_1.EOL);
        }
        else {
            newText = formattedLicense + os_1.EOL + fileContents;
        }
        fs.writeFileSync(filePath, newText);
    };
    LicenseManager.prototype.removeLicense = function (fileContents, normalisedLicense, filePath) {
        var fileLines = fileContents.split(/\r?\n/);
        var licenseLines = normalisedLicense.split(/\r?\n/).map(function (line) { return '^' + line; });
        fileLines.some(function (fileLine, idx) {
            if (fileLine.match(licenseLines[0])) {
                var match = fileLines.slice(idx + 1, idx + licenseLines.length).every(function (nextLine, subsetIdx) {
                    return nextLine.match(licenseLines[subsetIdx + 1]);
                });
                if (match) {
                    fileLines.splice(idx, licenseLines.length);
                    fs.writeFileSync(filePath, fileLines.join(os_1.EOL));
                    return true; // break out assume one license per file
                }
            }
            return false;
        });
    };
    LicenseManager.prototype.formatForCheck = function (textBlock, escapeRegex, regex) {
        var _this = this;
        var regexIdentifier = regex ? regex.identifier : null;
        var regexes;
        if (regexIdentifier) {
            var split = textBlock.split(regexIdentifier);
            if (split.length % 2 === 0) {
                throw new Error('Odd number of regex identifiers found. One must be missing its close');
            }
            textBlock = split.filter(function (_, idx) { return idx % 2 === 0; }).join(REGEX_MARKER);
            regexes = split.filter(function (_, idx) { return idx % 2 !== 0; });
        }
        var formatted = textBlock.split(/\r?\n/).map(function (line) {
            return _this.trailingWhitespace === config_parser_1.TrailingWhitespaceMode.DEFAULT ? line.replace(/\s+$/, '') : line;
        }).join('\n');
        if (escapeRegex) {
            formatted = formatted.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') // ESCAPE READY FOR REGEX
                .split(REGEX_MARKER).map(function (el, idx, orig) {
                return idx !== orig.length - 1 ? el + regexes[idx] : el;
            }).join('');
        }
        return formatted;
    };
    return LicenseManager;
}());
exports.LicenseManager = LicenseManager;
//# sourceMappingURL=license-manager.js.map