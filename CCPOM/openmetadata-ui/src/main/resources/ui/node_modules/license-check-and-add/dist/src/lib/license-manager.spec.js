"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai = __importStar(require("chai"));
var mockery = __importStar(require("mockery"));
var os_1 = require("os");
var sinon = __importStar(require("sinon"));
var sinon_chai_1 = __importDefault(require("sinon-chai"));
var constants_1 = require("../constants");
var config_parser_1 = require("./config-parser");
var license_formatter_1 = require("./license-formatter");
var license_manager_1 = require("./license-manager");
var expect = chai.expect;
chai.use(sinon_chai_1.default);
// tslint:disable: no-unused-expression
describe('#LicenseManager', function () {
    var sandbox;
    var LicenseManager;
    var LicenseFormatterStub;
    var mockLicenseFormatter;
    var licenseManager;
    var mockFormats = {
        css: {
            eachLine: {
                append: ' */',
                prepend: '/*',
            },
            prepend: ' * ',
        },
        js: {
            eachLine: {
                append: ' */',
                prepend: '/*',
            },
            prepend: ' * ',
        },
        sh: {
            eachLine: {
                prepend: '# ',
            },
        },
    };
    var mockRegex = {
        identifier: '##',
    };
    before(function () {
        mockery.enable({
            warnOnReplace: false,
            warnOnUnregistered: false,
        });
    });
    beforeEach(function () {
        sandbox = sinon.createSandbox();
        mockLicenseFormatter = sinon.createStubInstance(license_formatter_1.LicenseFormatter);
        LicenseFormatterStub = sandbox.stub().returns(mockLicenseFormatter);
        mockery.registerMock('./license-formatter', { LicenseFormatter: LicenseFormatterStub });
        delete require.cache[require.resolve('./license-manager')];
        LicenseManager = require('./license-manager').LicenseManager;
    });
    afterEach(function () {
        sandbox.restore();
        mockery.deregisterAll();
    });
    after(function () {
        mockery.disable();
    });
    describe('constructor', function () {
        it('should configure with a license formatter that lacks declared formats', function () {
            licenseManager = new LicenseManager(['some', 'paths'], 'some license text', null, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.TRIM, license_manager_1.ManagementMode.CHECK, 'some output path');
            expect(licenseManager.paths).to.deep.equal(['some', 'paths']);
            expect(LicenseFormatterStub).to.have.been.calledOnceWithExactly(constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.TRIM);
            expect(licenseManager.licenseFormatter).to.deep.equal(mockLicenseFormatter);
            expect(licenseManager.mode).to.deep.equal(license_manager_1.ManagementMode.CHECK);
            expect(licenseManager.outputPath).to.deep.equal('some output path');
        });
        it('should configure with a license formatter that has declared formats', function () {
            licenseManager = new LicenseManager(['some', 'paths'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.INSERT, 'some output path');
            expect(licenseManager.paths).to.deep.equal(['some', 'paths']);
            expect(LicenseFormatterStub).to.have.been.calledOnceWithExactly(constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, mockFormats);
            expect(licenseManager.licenseFormatter).to.deep.equal(mockLicenseFormatter);
            expect(licenseManager.mode).to.deep.equal(license_manager_1.ManagementMode.INSERT);
            expect(licenseManager.outputPath).to.deep.equal('some output path');
        });
        it('should configure with a regex value when supplied', function () {
            licenseManager = new LicenseManager(['some', 'paths'], 'some license text', null, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.TRIM, license_manager_1.ManagementMode.CHECK, 'some output path', mockRegex);
            expect(licenseManager.paths).to.deep.equal(['some', 'paths']);
            expect(LicenseFormatterStub).to.have.been.calledOnceWithExactly(constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.TRIM);
            expect(licenseManager.licenseFormatter).to.deep.equal(mockLicenseFormatter);
            expect(licenseManager.mode).to.deep.equal(license_manager_1.ManagementMode.CHECK);
            expect(licenseManager.outputPath).to.deep.equal('some output path');
            expect(licenseManager.regex).to.deep.equal(mockRegex);
        });
    });
    describe('manage', function () {
        var fsReadFileStub;
        var fsWriteFileStub;
        var consoleLogStub;
        var consoleErrorStub;
        beforeEach(function () {
            mockLicenseFormatter.formatLicenseForFile.returnsArg(1);
            fsReadFileStub = sandbox.stub().onFirstCall().returns('file without license')
                .onSecondCall().returns('some license\nin the file');
            fsWriteFileStub = sandbox.stub();
            consoleLogStub = sandbox.stub(console, 'log');
            consoleErrorStub = sandbox.stub(console, 'error');
            mockery.registerMock('fs-extra', { readFileSync: fsReadFileStub, writeFileSync: fsWriteFileStub });
            delete require.cache[require.resolve('./license-manager')];
            LicenseManager = require('./license-manager').LicenseManager;
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK);
        });
        function expect_to_read_files() {
            expect(fsReadFileStub.callCount).to.deep.equal(2);
            expect(fsReadFileStub).to.have.been.calledWithExactly('some.txt');
            expect(fsReadFileStub).to.have.been.calledWithExactly('.dotfile');
        }
        function expect_to_format_license(licenseText) {
            if (licenseText === void 0) { licenseText = 'some license'; }
            expect(mockLicenseFormatter.formatLicenseForFile.callCount).to.deep.equal(2);
            expect(mockLicenseFormatter.formatLicenseForFile).to.have.been.calledWithExactly('.txt', licenseText);
            expect(mockLicenseFormatter.formatLicenseForFile).to.have.been.calledWithExactly('.dotfile', licenseText);
        }
        it('should throw an error when missing licenses in check mode', function () {
            licenseManager.mode = license_manager_1.ManagementMode.CHECK;
            expect(function () {
                licenseManager.manage();
            }).to.throw(/License check failed. 1 file/);
            expect_to_read_files();
            expect_to_format_license();
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleLogStub).to.not.have.been.called;
            expect(consoleErrorStub).to.have.been.calledOnceWithExactly(sinon.match(/License not found in/), 'some.txt');
        });
        it('should not throw an error when all files have license in check mode', function () {
            fsReadFileStub.onFirstCall().returns('some license');
            licenseManager.mode = license_manager_1.ManagementMode.CHECK;
            licenseManager.manage();
            expect_to_read_files();
            expect_to_format_license();
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/All files have licenses/));
        });
        it('should throw an error when missing licenses in check mode using regex license template', function () {
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some ##l{2}icense##', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, null, mockRegex);
            expect(function () {
                licenseManager.manage();
            }).to.throw(/License check failed. 2 file\(s\)/);
            expect_to_read_files();
            expect_to_format_license('some ##l{2}icense##');
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleLogStub).to.not.have.been.called;
            expect(consoleErrorStub).to.have.been.calledTwice;
            expect(consoleErrorStub).to.have.been.calledWithExactly(sinon.match(/License not found in/), '.dotfile');
            expect(consoleErrorStub).to.have.been.calledWithExactly(sinon.match(/License not found in/), 'some.txt');
        });
        it('should not throw an error when all files have license in check mode using regex license template', function () {
            fsReadFileStub.onFirstCall().returns('some license');
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some ##l{1}icense##', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, null, mockRegex);
            licenseManager.manage();
            expect_to_read_files();
            expect_to_format_license('some ##l{1}icense##');
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/All files have licenses/));
        });
        it('should insert licenses to those missing without using regex', function () {
            licenseManager.mode = license_manager_1.ManagementMode.INSERT;
            var insertStub = sandbox.stub(licenseManager, 'insertLicense');
            licenseManager.manage();
            expect_to_read_files();
            expect_to_format_license();
            expect(insertStub).to.have.been
                .calledOnceWithExactly('file without license', 'some license', 'some.txt', undefined);
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/Inserted license into 1 file\(s\)/));
        });
        it('should insert licenses to those missing using regex license template', function () {
            var replacementRegex = Object.assign(mockRegex, { replacement: 'some replacement' });
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some ##l{1}icense##', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, null, replacementRegex);
            licenseManager.mode = license_manager_1.ManagementMode.INSERT;
            var insertStub = sandbox.stub(licenseManager, 'insertLicense');
            licenseManager.manage();
            expect_to_read_files();
            expect_to_format_license('some ##l{1}icense##');
            expect(insertStub).to.have.been
                .calledOnceWithExactly('file without license', 'some ##l{1}icense##', 'some.txt', replacementRegex);
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/Inserted license into 1 file\(s\)/));
        });
        it('should remove license from those with it', function () {
            licenseManager.mode = license_manager_1.ManagementMode.REMOVE;
            var removeStub = sandbox.stub(licenseManager, 'removeLicense');
            licenseManager.manage();
            expect_to_read_files();
            expect_to_format_license();
            expect(removeStub).to.have.been
                .calledOnceWithExactly('some license\nin the file', 'some license', '.dotfile');
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/Removed license from 1 file\(s\)/));
        });
        it('should remove license from those with it with regex license template', function () {
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some ##l{1}icense##', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, null, mockRegex);
            licenseManager.mode = license_manager_1.ManagementMode.REMOVE;
            var removeStub = sandbox.stub(licenseManager, 'removeLicense');
            licenseManager.manage();
            expect_to_read_files();
            expect_to_format_license('some ##l{1}icense##');
            expect(removeStub).to.have.been
                .calledOnceWithExactly('some license\nin the file', 'some l{1}icense', '.dotfile');
            expect(fsWriteFileStub).to.not.have.been.called;
            expect(consoleErrorStub).to.not.have.been.called;
            expect(consoleLogStub).to.have.been.calledOnceWithExactly(sinon.match(/Removed license from 1 file\(s\)/));
        });
        it('should write to output path when requested in check mode', function () {
            licenseManager.mode = license_manager_1.ManagementMode.CHECK;
            licenseManager.outputPath = 'some output';
            expect(function () {
                licenseManager.manage();
            }).to.throw(/License check failed. 1 file/);
            expect(fsWriteFileStub).to.have.been.calledOnceWithExactly('some output', ['some.txt'].join(os_1.EOL));
        });
        it('should write to output path when requested in insert mode', function () {
            licenseManager.mode = license_manager_1.ManagementMode.INSERT;
            licenseManager.outputPath = 'some output';
            sandbox.stub(licenseManager, 'insertLicense');
            licenseManager.manage();
            expect(fsWriteFileStub).to.have.been.calledOnceWithExactly('some output', ['some.txt'].join(os_1.EOL));
        });
        it('should write to output path when requested in remove mode', function () {
            licenseManager.mode = license_manager_1.ManagementMode.REMOVE;
            licenseManager.outputPath = 'some output';
            sandbox.stub(licenseManager, 'removeLicense');
            licenseManager.manage();
            expect(fsWriteFileStub).to.have.been.calledOnceWithExactly('some output', ['.dotfile'].join(os_1.EOL));
        });
        it('should store the license for an extension', function () {
            fsReadFileStub.onFirstCall().returns('some license');
            licenseManager.mode = license_manager_1.ManagementMode.CHECK;
            licenseManager.manage();
            var formattedLicenses = licenseManager.formattedLicenses;
            expect(formattedLicenses).to.have.lengthOf(2);
            expect(formattedLicenses.has('.txt')).to.be.true;
            expect(formattedLicenses.has('.dotfile')).to.be.true;
            expect(formattedLicenses.get('.txt')).to.deep.equal({ formatted: 'some license', normalised: 'some license' });
            expect(formattedLicenses.get('.dotfile')).to.deep.equal({ formatted: 'some license', normalised: 'some license' });
        });
        it('should use an existing stored license if the extension has already been handled', function () {
            fsReadFileStub.onFirstCall().returns('some license');
            licenseManager.mode = license_manager_1.ManagementMode.CHECK;
            licenseManager.formattedLicenses = new Map([
                [
                    '.txt', { formatted: 'some license', normalised: 'some license' },
                ],
                [
                    '.dotfile', { formatted: 'some license', normalised: 'some license' },
                ]
            ]);
            licenseManager.manage();
            expect(mockLicenseFormatter.formatLicenseForFile.callCount).to.deep.equal(0);
        });
    });
    describe('insertLicense', function () {
        var fsWriteFileStub;
        beforeEach(function () {
            mockLicenseFormatter.formatLicenseForFile.returns('some license');
            fsWriteFileStub = sandbox.stub();
            mockery.registerMock('fs-extra', { writeFileSync: fsWriteFileStub });
            delete require.cache[require.resolve('./license-manager')];
            LicenseManager = require('./license-manager').LicenseManager;
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path');
        });
        it('should write license to start of file when no shebang', function () {
            licenseManager.insertLicense('some file contents', 'some license', 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some license' + os_1.EOL + 'some file contents');
        });
        it('should write license after shebang in file when shebang', function () {
            licenseManager.insertLicense('#!ooh shebang\nsome file contents', 'some license', 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', '#!ooh shebang' + os_1.EOL + 'some license' + os_1.EOL + 'some file contents');
        });
        it('should error when replacement value passed does not match regex', function () {
            var replacementRegex = Object.assign(mockRegex, { replacements: ['license', '123'] });
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path', replacementRegex);
            expect(function () {
                licenseManager.insertLicense('some file contents', 'some ##l{1}icense## ##[1-9]{4}##', 'some file', replacementRegex);
            }).to.throw('Replacement value 123 does not match regex it is to replace: [1-9]{4}');
        });
        it('should error when single replacement value passed does not match regex but matches another', function () {
            var replacementRegex = Object.assign(mockRegex, { replacements: ['license'] });
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path', replacementRegex);
            expect(function () {
                licenseManager.insertLicense('some file contents', 'some ##l{1}icense## ##[1-9]{4}##', 'some file', replacementRegex);
            }).to.throw('Replacement value license does not match regex it is to replace: [1-9]{4}');
        });
        it('should error when multiple replacement values are passed but there are more regex values', function () {
            var replacementRegex = Object.assign(mockRegex, { replacements: ['license', '123'] });
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path', replacementRegex);
            expect(function () {
                licenseManager.insertLicense('some file contents', 'some ##l{1}icense## ##[1-9]{3}##\n##[a-z]{4}##', 'some file', replacementRegex);
            }).to.throw("Too few replacement values passed. Found at least 3 regex values. Only have 2 replacements");
        });
        it('should write license to start of file replacing the regex when multiple supplied', function () {
            var replacementRegex = Object.assign(mockRegex, { replacements: ['license', '123'] });
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path', replacementRegex);
            licenseManager.insertLicense('some file contents', 'some ##l{1}icense## ##[1-9]{3}##', 'some file', replacementRegex);
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some license 123' + os_1.EOL + 'some file contents');
        });
        it('should write license to start of file replacing the regex when only one supplied', function () {
            var replacementRegex = Object.assign(mockRegex, { replacements: ['replacement'] });
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path', replacementRegex);
            licenseManager.insertLicense('some file contents', 'some ##[a-z]{11}## ##[a-z]{11}##', 'some file', replacementRegex);
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some replacement replacement' + os_1.EOL + 'some file contents');
        });
        it('should write license to start of file replacing the regex when multiple supplied over new lines', function () {
            var replacementRegex = Object.assign(mockRegex, { replacements: ['license', 'andy', 'made'] });
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path', replacementRegex);
            licenseManager.insertLicense('some file contents', 'some ##l{1}icense## ##[a-z]{4}##\n##.*##', 'some file', replacementRegex);
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some license andy\nmade' + os_1.EOL + 'some file contents');
        });
    });
    describe('removeLicense', function () {
        var fsWriteFileStub;
        beforeEach(function () {
            mockLicenseFormatter.formatLicenseForFile.returns('some license');
            fsWriteFileStub = sandbox.stub();
            mockery.registerMock('fs-extra', { writeFileSync: fsWriteFileStub });
            delete require.cache[require.resolve('./license-manager')];
            LicenseManager = require('./license-manager').LicenseManager;
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path');
        });
        it('should do nothing when no license', function () {
            licenseManager.removeLicense('some file contents', 'some license', 'some file');
            expect(fsWriteFileStub).to.not.have.been.called;
        });
        it('should remove single line license when present', function () {
            licenseManager.removeLicense('some license\nsome file contents', 'some license', 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some file contents');
        });
        it('should remove multi line license when present', function () {
            var multiLineLicense = 'some\nmulti line\nlicense';
            licenseManager.removeLicense(multiLineLicense + '\nsome file contents', multiLineLicense, 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some file contents');
        });
        it('should handle when partial match of license is present and leave that but remove full license', function () {
            var multiLineLicense = 'some\nmulti line\nlicense';
            licenseManager.removeLicense('some\nmulti line\nlike license\n' + multiLineLicense + '\nsome file contents', multiLineLicense, 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some\nmulti line\nlike license\nsome file contents');
        });
        it('should handle when regex is used in the license', function () {
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path', mockRegex);
            licenseManager.removeLicense('some license\nsome file contents', 'some l{1}icense', 'some file');
            expect(fsWriteFileStub).to.have.been.calledWithExactly('some file', 'some file contents');
        });
    });
    describe('formatForCheck', function () {
        beforeEach(function () {
            licenseManager = new LicenseManager(['some.txt', '.dotfile'], 'some license text', mockFormats, constants_1.DEFAULT_FORMAT, config_parser_1.TrailingWhitespaceMode.DEFAULT, license_manager_1.ManagementMode.CHECK, 'some output path');
        });
        it('should normalise line endings and trim whitespace', function () {
            var multiLineLicense = 'some\r\nmulti line   \r\nlicense ';
            var formatted = licenseManager.formatForCheck(multiLineLicense, true);
            expect(formatted).to.deep.equal('some\nmulti line\nlicense');
        });
        it('should normalise line endings and leave whitespace', function () {
            licenseManager.trailingWhitespace = config_parser_1.TrailingWhitespaceMode.TRIM;
            var multiLineLicense = 'some\r\nmulti line   \r\nlicense ';
            var formatted = licenseManager.formatForCheck(multiLineLicense, true);
            expect(formatted).to.deep.equal('some\nmulti line   \nlicense ');
        });
        it('should throw an error when regex identifier is not closed', function () {
            var multiLineLicense = 'some\r\n##multi line   \r\n##l{1}cense## with bad regex identifying';
            expect(function () {
                licenseManager.formatForCheck(multiLineLicense, false, mockRegex);
            }).to.throw('Odd number of regex identifiers found. One must be missing its close');
        });
        it('should normalise and handle regex', function () {
            var multiLineLicense = 'some\r\nmulti line   \r\n##l{1}cense## with regex ';
            var formatted = licenseManager.formatForCheck(multiLineLicense, true, mockRegex);
            expect(formatted).to.deep.equal('some\nmulti line\nl{1}cense with regex');
        });
        it('should normalise and handle regex when regex and escape characters in non regex', function () {
            var multiLineLicense = 'some\r\nmulti line (ooh bracket)  \r\n##l{1}cense## with regex ';
            var formatted = licenseManager.formatForCheck(multiLineLicense, true, mockRegex);
            expect(formatted).to.deep.equal('some\nmulti line \\(ooh bracket\\)\nl{1}cense with regex');
        });
        it('should normalise and but not escape regex', function () {
            var multiLineLicense = 'some\r\nmulti line   \r\nwith regex ^characters$';
            var formatted = licenseManager.formatForCheck(multiLineLicense, false, mockRegex);
            expect(formatted).to.deep.equal('some\nmulti line\nwith regex ^characters$');
        });
    });
});
//# sourceMappingURL=license-manager.spec.js.map