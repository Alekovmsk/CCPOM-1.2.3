"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai = __importStar(require("chai"));
var mockery = __importStar(require("mockery"));
var path = __importStar(require("path"));
var sinon = __importStar(require("sinon"));
var sinon_chai_1 = __importDefault(require("sinon-chai"));
var constants_1 = require("../constants");
var config_parser_1 = require("../lib/config-parser");
var file_finder_1 = require("../lib/file-finder");
var license_manager_1 = require("../lib/license-manager");
var expect = chai.expect;
chai.use(sinon_chai_1.default);
describe('#CommandUtils', function () {
    var sandbox;
    var getPathsStub;
    var LicenseManagerStub;
    var mockLicenseManager;
    var configParserStub;
    var MockUtils;
    var mockConfig = {
        defaultFormat: constants_1.DEFAULT_FORMAT,
        ignore: ['some', 'stuff', 'to', 'ignore'],
        ignoreDefaultIgnores: true,
        ignoreFile: 'some/ignore/path',
        license: 'some license',
        licenseFormats: {},
        trailingWhitespace: config_parser_1.TrailingWhitespaceMode.DEFAULT,
    };
    before(function () {
        mockery.enable({
            warnOnReplace: false,
            warnOnUnregistered: false,
        });
    });
    beforeEach(function () {
        sandbox = sinon.createSandbox();
        mockLicenseManager = sandbox.createStubInstance(license_manager_1.LicenseManager);
        LicenseManagerStub = sandbox.stub().returns(mockLicenseManager);
        mockery.registerMock('../lib/license-manager', { LicenseManager: LicenseManagerStub });
        configParserStub = sandbox.stub(config_parser_1.ConfigParser, 'parse').returns(mockConfig);
        getPathsStub = sandbox.stub(file_finder_1.FileFinder, 'getPaths').returns(['some paths']);
        delete require.cache[require.resolve('./utils.ts')];
        MockUtils = require('./utils.ts');
    });
    afterEach(function () {
        sandbox.restore();
        mockery.deregisterAll();
    });
    after(function () {
        mockery.disable();
    });
    describe('addExports', function () {
        it('should add to exports', function () {
            var mockExports = {};
            var mockCommandModule = {
                aliases: 'some alias',
                builder: 'some builder',
                command: 'some command',
                describe: 'some description',
                helper: 'some helper',
            };
            MockUtils.addExports(mockExports, mockCommandModule);
            expect(mockExports).to.deep.equal(mockCommandModule);
        });
    });
    describe('manageLicense', function () {
        it('should setup license manager and manage handling when regex contains numbers', function () {
            var mockArgs = {};
            mockArgs[constants_1.CONFIG_OPTION] = 'some config file';
            mockArgs[constants_1.REGEX_OPTION] = ['some regex option', 2];
            var expectedConfigPath = path.resolve(process.cwd(), 'some config file');
            MockUtils.manageLicense(mockArgs, license_manager_1.ManagementMode.CHECK);
            expect(configParserStub).to.have.been.calledOnceWithExactly(expectedConfigPath, license_manager_1.ManagementMode.CHECK, ['some regex option', '2']);
            expect(getPathsStub).to.have.been.calledOnceWithExactly(mockConfig.ignore, mockConfig.ignoreDefaultIgnores, mockConfig.ignoreFile);
            expect(LicenseManagerStub).to.have.been.calledOnceWithExactly(['some paths'], mockConfig.license, mockConfig.licenseFormats, mockConfig.defaultFormat, mockConfig.trailingWhitespace, license_manager_1.ManagementMode.CHECK, mockConfig.output, mockConfig.regex);
            expect(mockLicenseManager.manage).to.have.been.calledOnceWithExactly();
        });
        it('should setup license manager and manage handling when no regex passed', function () {
            var mockArgs = {};
            mockArgs[constants_1.CONFIG_OPTION] = 'some config file';
            mockArgs[constants_1.REGEX_OPTION] = undefined;
            var expectedConfigPath = path.resolve(process.cwd(), 'some config file');
            MockUtils.manageLicense(mockArgs, license_manager_1.ManagementMode.CHECK);
            expect(configParserStub).to.have.been.calledOnceWithExactly(expectedConfigPath, license_manager_1.ManagementMode.CHECK, undefined);
            expect(getPathsStub).to.have.been.calledOnceWithExactly(mockConfig.ignore, mockConfig.ignoreDefaultIgnores, mockConfig.ignoreFile);
            expect(LicenseManagerStub).to.have.been.calledOnceWithExactly(['some paths'], mockConfig.license, mockConfig.licenseFormats, mockConfig.defaultFormat, mockConfig.trailingWhitespace, license_manager_1.ManagementMode.CHECK, mockConfig.output, mockConfig.regex);
            expect(mockLicenseManager.manage).to.have.been.calledOnceWithExactly();
        });
    });
});
//# sourceMappingURL=utils.spec.js.map