let TagsExtractor = function (sourcesPath, fileExt) {

  this.sourcesPath = sourcesPath;
  this.fileExt = fileExt;

  this.regex = {
    client: /(?:tr|trDom)([\t\r\n ]*)\(([\t\r\n ]*)msgs\.[A-Za-z0-9|\_|\.]+/g,
    server: /rb.getMessage\(TranslationTags.[A-Za-z0-9|\_]+/g
  };
  this.regexTrim = {
    client: 'tr(msgs.',
    server: 'rb.getMessage(TranslationTags.'
  };
};

TagsExtractor.prototype.getFileContents = function (directory, fileName) {
  var fileContents = '';
  var fileExt = this.fileExt;
  var hasProperExtension = path.extname(fileName) === fileExt;
  if (hasProperExtension) {
    fileContents = fs.readFileSync(directory + '/' + fileName, 'utf8');
  } else {
    // take html file extensions too.
    if (fileExt === '.js') {
      var isHtml = path.extname(fileName) === '.html';
      if (isHtml) {
        fileContents = fs.readFileSync(directory + '/' + fileName, 'utf8');
      }
    }
  }
  return fileContents;
};

TagsExtractor.prototype.isClientSideTestFile = function (fileName) {
  // TODO: use something more powerful to set up exclude paths.
  var onlyFileName = path.basename(fileName, path.extname(fileName));
  return onlyFileName.indexOf('test_') !== -1;
};

TagsExtractor.prototype.recursiveReadDir = function (directory) {
  var fileContents = '';
  if (fs.existsSync(directory)) {
    var filenames = fs.readdirSync(directory);
    for (var i = 0; i < filenames.length; i++) {
      // Do not detect tags used in the test files of this module.
      if (filenames[i].indexOf('node_modules') !== -1) {
        continue;
      }

      var isDirectory = fs.lstatSync(directory + '/' + filenames[i]).isDirectory();
      if (isDirectory) {
        this.recursiveReadDir(directory + '/' + filenames[i]);
      } else {
        if (!this.isClientSideTestFile(filenames[i])) {
          fileContents += this.getFileContents(directory, filenames[i]);
        }
      }
    }
  } else {
    console.warn('WARNING: [' + tagsType + '-side-tags]' + ' Could not find folder: ', directory);
  }
  return fileContents;
};

/**
 * Get the tags of a certain type from the source files.
 * @param tagsType The type of tags to get.
 * @return {RegExpMatchArray} The tags found.
 */
TagsExtractor.prototype.extractTagsStatic = function (tagsType) {
  var fileContents = this.recursiveReadDir(this.sourcesPath);
  return this.findTagsInString(fileContents, tagsType);
};

/**
 * Apply the regex to a string (all targeted files concatenated usually) to extract the tags.
 * @param fileContents The string created from concatenating the source files of a certain type.
 * @param tagsType The type of tags to extract.
 * @returns {Array<string>} The list of tags found.
 */
TagsExtractor.prototype.findTagsInString = function (fileContents, tagsType) {
  var regex = this.regex[tagsType];
  var regexTrim = this.regexTrim[tagsType];
  // Find tags.
  var tagsFromFile = fileContents.match(regex);
  if (tagsFromFile) {
    tagsFromFile = tagsFromFile.map(function (tag) {
      if (tagsType === 'server') {
        return tag.replace(regexTrim, '');
      } else {
        tag = tag.substring(tag.indexOf('(') + 1);
        tag = tag.trim();
        return tag.replace('msgs.', '');
      }
    });

    // Remove duplicates.
    tagsFromFile = tagsFromFile.filter(function(item, pos) {
      return tagsFromFile.indexOf(item) === pos;
    });
  }
  return tagsFromFile;
};

module.exports = TagsExtractor;